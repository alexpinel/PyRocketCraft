"""
  Validate a trained network.

  (c) Jan Zwiener (jan@zwiener.org)
"""

import json
import numpy as np
import torch
from torch import nn
from torch import optim
from torch.utils.data import TensorDataset, DataLoader

from nnpolicynetwork import NNPolicyNetwork
from nnpolicy import NNPolicy

def expert_validate(input_file = "expert_data_previous.json",
                    output_file = "torch_nn_mpc-rocket-v2.pth"):
    """
      (!) This requires as trained network
      in e.g. "torch_nn_mpc-rocket-vX.pth".
    """

    print("Loading data from file: %s ..." % input_file)
    # Load training data, e.g. generated by the MPC controller
    with open(input_file, "r", encoding="utf-8") as file:
        data = json.load(file)

    print("Found %i state/action pairs" % (len(data)))
    # Assuming each entry in data is a dictionary with 'obs' and 'acts' keys
    observations = np.array([item['obs'] for item in data])
    actions = np.array([item['acts'] for item in data])
    # Predicted state vectors can also be stored in the JSON file
    # predictedX = np.array([item['predictedX'] for item in data])

    # try to use CUDA if available
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    print(f"PyTorch: using {device}")

    # Setting up pytorch
    observations = torch.tensor(observations, dtype=torch.float32)
    actions = torch.tensor(actions, dtype=torch.float32)
    dataset = TensorDataset(observations, actions)
    data_loader = DataLoader(dataset, batch_size=64, shuffle=True)
    input_size = observations.shape[1]
    output_size = actions.shape[1]
    criterion = nn.MSELoss()
    model = NNPolicyNetwork(input_size, output_size)
    model.load_state_dict(torch.load(output_file))
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    model = model.to(device)
    model.eval()  # Set the model to inference mode

    with torch.no_grad():
        validation_loss = 0.0
        for inputs, targets in data_loader:
            inputs, targets = inputs.to(device), targets.to(device)
            outputs = model(inputs)
            loss = criterion(outputs, targets)
            validation_loss += loss.item()

        avg_validation_loss = validation_loss / len(data_loader)
        print(f'Validation Loss: {avg_validation_loss:.4f}')

if __name__ == '__main__':
    expert_validate()
